Solution One 为 双指针法：
    以以下测试样例为例：
        intersectVal = 8;
        ListA = [4,1,8,4,5];
        ListB = [5,6,1,8,4,5];
        skipA = 2；
        skipB = 3;
    两链表相交于 val 为 8 的节点处。
    首先我想到的是利用头插法将两链表变为逆序链表，但是题目中要求不能改变链表原本的数据结构，因此放弃此方法。
    然后，我想到将两个链表以不同的顺序组合起来：
    4->1->8->4->5->5->6->1->8->4->5
    5->6->1->8->4->5->4->1->8->4->5
    我们可以观察到，如果使用两个指针分别从上述两个组合链表的头节点处开始遍历链表，并比较指针处的节点是否为同一个节点，
    则会发现在指针指向 val 为 8 的节点时，找到两个链表相交的节点。
    假设两链表相交的长度为c，链表 A 的总长度为 a + c，链表 B 的总长度为 b + c
    则组合链表相当于：
    a + c + b + c
    b + c + a + c
    根据加法交换律，可以发现它们的前三部分相加的值相同，使用双指针遍历可以寻找到它们的交点。
    
    时间复杂度：O(m + n), m 和 n 分别为两链表的长度
    空间复杂度：O(1) 未创建新的容器