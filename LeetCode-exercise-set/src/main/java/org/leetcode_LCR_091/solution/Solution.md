本解法使用动态规划来解题：
    1.状态表示：
        dp[i][0] 表示粉刷到第 i + 1 个房子时，粉刷为红色的最小花费；
        dp[i][1] 表示粉刷到第 i + 1 个房子时，粉刷为蓝色的最小花费；
        dp[i][2] 表示粉刷到第 i + 1 个房子时，粉刷为绿色的最小花费；
    2.状态转移方程：
        粉刷为红色时，前一个房子必然是蓝色或绿色
        dp[i][0] = Math.min(dp[i - 1][1], dp[i - 1][2]) + costs[i][0];
        粉刷为蓝色时，前一个房子必然是蓝色或绿色
        dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][2]) + costs[i][1];
        粉刷为绿色时，前一个房子必然是蓝色或绿色
        dp[i][2] = Math.min(dp[i - 1][0], dp[i - 1][1]) + costs[i][2];
    3.初始化：
        第一行根据状态表示的意义进行初始化，应当初始化为 costs 数组的第一行；
    4.填表顺序：
        从第 0 行开始逐行填表，每次都把整行填满；
    5.返回值：
        返回 dp 数组最后一行的最小值。
        